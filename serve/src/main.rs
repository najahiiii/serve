mod config;
mod template;
mod utils;

use axum::{
    Router,
    body::Body,
    extract::{DefaultBodyLimit, Multipart, Path, Query, State, multipart::MultipartError},
    http::{Extensions, HeaderMap, HeaderValue, StatusCode, Version, header},
    response::{IntoResponse, Response},
    routing::{get, post},
};
use chrono::{Datelike, Local};
use clap::{Args, Parser, Subcommand};
use config::Config;
use html_escape::encode_text;
use mime_guess::MimeGuess;
use pathdiff::diff_paths;
use serde::Deserialize;
use std::{
    env, fmt, io,
    net::SocketAddr,
    path::{Path as StdPath, PathBuf},
    sync::Arc,
};
use tokio::fs;
use tokio::io::{AsyncReadExt, AsyncSeekExt, AsyncWriteExt};
use tokio_util::io::ReaderStream;
use tower::ServiceBuilder;
use tower_http::{
    compression::CompressionLayer, set_header::SetResponseHeaderLayer, trace::TraceLayer,
};
use tracing::{error, info};
use tracing_subscriber::EnvFilter;
use utils::{
    encode_link, format_modified_time, format_size, is_allowed_file, is_blacklisted,
    resolve_within_root, secure_filename,
};

const NOT_FOUND_MESSAGE: &str = "Files or Directory not found or missing";
const DEFAULT_CONFIG_BODY: &str = r#"# Generated by serve
port = 3435
root = "./serve"
upload_token = "abogoboga"
max_file_size = 4194304000
blacklisted_files = ["utils", "server.py"]
allowed_extensions = [
  "mp3", "wav", "mp4", "zip", "pdf", "png", "jpg"
]
"#;
const POWERED_BY: &str = concat!("serve/", env!("CARGO_PKG_VERSION"));
// Smaller chunk keeps initial response snappy while still streaming efficiently.
const STREAM_BUFFER_BYTES: usize = 256 * 1024;

#[derive(Parser)]
#[command(
    name = "serve",
    version,
    about = "Serve files over HTTP with optional upload support.",
    long_about = None
)]
struct Cli {
    #[command(subcommand)]
    command: Command,
}

#[derive(Args, Clone)]
struct RunArgs {
    /// Path to configuration file (TOML format)
    #[arg(long, value_name = "FILE")]
    config: Option<PathBuf>,
    /// Override listening port (defaults to env/config)
    #[arg(long, value_name = "PORT")]
    port: Option<u16>,
    /// Override upload token
    #[arg(long, value_name = "TOKEN")]
    upload_token: Option<String>,
    /// Override maximum upload size in bytes
    #[arg(long, value_name = "BYTES")]
    max_file_size: Option<u64>,
    /// Override root directory to serve
    #[arg(long, value_name = "PATH")]
    root: Option<PathBuf>,
}

#[derive(Subcommand)]
enum Command {
    /// Run the HTTP file server
    Run(RunArgs),
    /// Generate a default configuration file at $HOME/.config/serve/config.toml
    InitConfig,
    /// Print the effective configuration and exit
    ShowConfig(RunArgs),
}

#[derive(Clone)]
struct AppState {
    config: Arc<Config>,
    canonical_root: Arc<PathBuf>,
}

#[tokio::main(flavor = "multi_thread", worker_threads = 4)]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    tracing_subscriber::fmt()
        .with_env_filter(
            EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| EnvFilter::new("serve=info,tower_http=info")),
        )
        .init();

    match Cli::parse().command {
        Command::Run(args) => run_server(args)
            .await
            .map_err(|err| -> Box<dyn std::error::Error> { Box::new(err) })?,
        Command::InitConfig => init_config_file()?,
        Command::ShowConfig(args) => show_config(args)?,
    }

    Ok(())
}

fn effective_config(args: &RunArgs) -> Result<(Config, PathBuf), AppError> {
    let mut config =
        Config::load(args.config.as_deref()).map_err(|err| AppError::Config(err.to_string()))?;

    if let Some(port) = args.port {
        config.port = port;
    }
    if let Some(token) = args.upload_token.clone() {
        config.upload_token = token;
    }
    if let Some(size) = args.max_file_size {
        config.max_file_size = size;
    }
    if let Some(root) = args.root.clone() {
        config.root_override = Some(root);
    }

    let base_root = config
        .root_override
        .clone()
        .unwrap_or_else(|| env::current_dir().unwrap_or_else(|_| PathBuf::from(".")));
    let canonical_root = base_root
        .canonicalize()
        .map_err(|_| AppError::Internal("Failed to resolve root directory".to_string()))?;

    Ok((config, canonical_root))
}

async fn run_server(args: RunArgs) -> Result<(), AppError> {
    let (config, canonical_root) = effective_config(&args)?;

    let body_limit = config
        .max_file_size
        .saturating_add(32 * 1024 * 1024)
        .try_into()
        .unwrap_or(usize::MAX);

    let state = AppState {
        config: Arc::new(config),
        canonical_root: Arc::new(canonical_root),
    };

    let compression = CompressionLayer::new().compress_when(
        |_status: StatusCode, _version: Version, headers: &HeaderMap, _extensions: &Extensions| {
            headers
                .get(header::CONTENT_TYPE)
                .and_then(|value| value.to_str().ok())
                .map(|content_type| {
                    content_type.starts_with("text/")
                        || content_type.contains("json")
                        || content_type.contains("xml")
                        || content_type.contains("javascript")
                })
                .unwrap_or(false)
        },
    );

    let powered_layer = SetResponseHeaderLayer::if_not_present(
        header::HeaderName::from_static("x-powered-by"),
        HeaderValue::from_static(POWERED_BY),
    );

    let router = Router::new()
        .route("/", get(get_root))
        .route("/*path", get(get_path))
        .route("/upload", post(handle_upload))
        .layer(DefaultBodyLimit::max(body_limit))
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(compression)
                .layer(powered_layer),
        )
        .with_state(state.clone());

    let addr = SocketAddr::from(([0, 0, 0, 0], state.config.port));
    info!(
        "Config loaded: port={} token_set={} max_file_size={} allowed_ext={} hidden={}",
        state.config.port,
        !state.config.upload_token.is_empty(),
        state.config.max_file_size,
        state.config.allowed_extensions.len(),
        state.config.blacklisted_files.len()
    );
    info!(
        "Starting server on {} serving {}",
        addr,
        state.canonical_root.display()
    );
    axum::serve(
        tokio::net::TcpListener::bind(addr)
            .await
            .map_err(map_io_error)?,
        router,
    )
    .await
    .map_err(|err| {
        error!("Server error: {}", err);
        AppError::Internal("Server error".to_string())
    })
}

fn show_config(args: RunArgs) -> Result<(), AppError> {
    let (config, canonical_root) = effective_config(&args)?;

    println!("serve {}", env!("CARGO_PKG_VERSION"));
    println!(
        "Config file    : {}",
        args.config
            .as_ref()
            .map(|p| p.display().to_string())
            .unwrap_or_else(|| "<auto-discovery>".to_string())
    );
    println!("Port           : {}", config.port);
    println!("Root (effective): {}", canonical_root.display());
    println!(
        "Root override  : {}",
        config
            .root_override
            .as_ref()
            .map(|p| p.display().to_string())
            .unwrap_or_else(|| "<not set>".to_string())
    );
    println!(
        "Upload token   : {}",
        if config.upload_token.is_empty() {
            "<not set>".to_string()
        } else {
            config.upload_token.clone()
        }
    );
    println!("Max file size  : {} bytes", config.max_file_size);

    let mut hidden: Vec<_> = config.blacklisted_files.iter().cloned().collect();
    hidden.sort();
    println!(
        "Hidden entries : {}",
        if hidden.is_empty() {
            "-".to_string()
        } else {
            hidden.join(", ")
        }
    );

    let mut extensions: Vec<_> = config.allowed_extensions.iter().cloned().collect();
    extensions.sort();
    println!(
        "Allowed ext    : {}",
        if extensions.is_empty() {
            "-".to_string()
        } else {
            extensions.join(", ")
        }
    );

    Ok(())
}

async fn get_root(
    State(state): State<AppState>,
    headers: HeaderMap,
    Query(query): Query<ViewQuery>,
) -> Result<Response, AppError> {
    serve_path(state, headers, "", query).await
}

async fn get_path(
    State(state): State<AppState>,
    Path(path): Path<String>,
    headers: HeaderMap,
    Query(query): Query<ViewQuery>,
) -> Result<Response, AppError> {
    serve_path(state, headers, &path, query).await
}

#[derive(Debug, Deserialize)]
struct ViewQuery {
    #[serde(default)]
    view: Option<bool>,
}

#[derive(Debug, Deserialize)]
struct UploadQuery {
    #[serde(default)]
    path: Option<String>,
}

async fn serve_path(
    state: AppState,
    headers: HeaderMap,
    requested_path: &str,
    query: ViewQuery,
) -> Result<Response, AppError> {
    let full_path = resolve_within_root(&state.canonical_root, requested_path)
        .ok_or_else(|| AppError::NotFound(NOT_FOUND_MESSAGE.to_string()))?;

    if is_blacklisted(
        &full_path,
        &state.canonical_root,
        &state.config.blacklisted_files,
    ) {
        return Err(AppError::NotFound(NOT_FOUND_MESSAGE.to_string()));
    }

    let metadata = match fs::metadata(&full_path).await {
        Ok(meta) => meta,
        Err(err) => return Err(map_io_error(err)),
    };

    if metadata.is_dir() {
        render_directory(&state, &headers, requested_path, full_path).await
    } else if metadata.is_file() {
        serve_file(
            &headers,
            requested_path,
            full_path,
            metadata,
            query.view.unwrap_or(false),
        )
        .await
    } else {
        Err(AppError::NotFound(NOT_FOUND_MESSAGE.to_string()))
    }
}

async fn render_directory(
    state: &AppState,
    headers: &HeaderMap,
    requested_path: &str,
    directory_path: PathBuf,
) -> Result<Response, AppError> {
    let mut entries = Vec::new();
    let mut read_dir = fs::read_dir(&directory_path).await.map_err(map_io_error)?;

    while let Some(entry) = read_dir.next_entry().await.map_err(map_io_error)? {
        let file_name_os = entry.file_name();
        let file_name = match file_name_os.to_str() {
            Some(name) => name.to_string(),
            None => continue,
        };

        let child_path = entry.path();
        if is_blacklisted(
            &child_path,
            &state.canonical_root,
            &state.config.blacklisted_files,
        ) {
            continue;
        }

        let child_metadata = match entry.metadata().await {
            Ok(metadata) => metadata,
            Err(err) => {
                error!("Skipping {}: {}", child_path.display(), err);
                continue;
            }
        };

        let modified = match child_metadata.modified() {
            Ok(time) => time,
            Err(err) => {
                error!("Failed to read mtime for {}: {}", child_path.display(), err);
                continue;
            }
        };
        let is_dir = child_metadata.is_dir();
        let display_name = if is_dir {
            format!("{}/", file_name)
        } else {
            file_name.clone()
        };
        let link = entry_link(requested_path, &file_name);
        let relative_url = encode_link(&link);
        let size_bytes = if is_dir { 0 } else { child_metadata.len() };
        let size_display = if is_dir {
            "-".to_string()
        } else {
            format_size(size_bytes)
        };
        let modified_local: chrono::DateTime<Local> = modified.into();
        let modified_display = format_modified_time(modified_local);
        let mime_type = if is_dir {
            "inode/directory".to_string()
        } else {
            MimeGuess::from_path(&child_path)
                .first_raw()
                .unwrap_or("application/octet-stream")
                .to_string()
        };

        entries.push(DirectoryEntry {
            name: file_name,
            display_name,
            relative_url,
            size_bytes,
            size_display,
            modified_display,
            is_dir,
            mime_type,
        });
    }

    entries.sort_by(|a, b| a.name.to_lowercase().cmp(&b.name.to_lowercase()));

    if headers
        .get("X-Serve-Client")
        .and_then(|value| value.to_str().ok())
        .map(|value| value.eq_ignore_ascii_case("serve-cli"))
        .unwrap_or(false)
    {
        let base_url = build_base_url(headers);
        let base_trimmed = base_url.trim_end_matches('/');
        let entries_json: Vec<_> = entries
            .iter()
            .enumerate()
            .map(|(idx, entry)| {
                let absolute = format!("{}{}", base_trimmed, entry.relative_url);
                serde_json::json!({
                    "index": idx + 1,
                    "name": entry.name,
                    "size": entry.size_display,
                    "size_bytes": entry.size_bytes,
                    "modified": entry.modified_display,
                    "url": absolute,
                    "is_dir": entry.is_dir,
                    "mime_type": entry.mime_type,
                })
            })
            .collect();

        let mut normalized_path = if requested_path.is_empty() {
            "/".to_string()
        } else {
            let mut p = format!("/{}", requested_path.trim_start_matches('/'));
            if !p.ends_with('/') {
                p.push('/');
            }
            p
        };
        if normalized_path.is_empty() {
            normalized_path = "/".to_string();
        }

        let payload = serde_json::json!({
            "path": normalized_path,
            "entries": entries_json,
            "powered_by": POWERED_BY,
        });

        let body =
            serde_json::to_vec(&payload).map_err(|err| AppError::Internal(err.to_string()))?;

        return Ok(Response::builder()
            .status(StatusCode::OK)
            .header(header::CONTENT_TYPE, "application/json; charset=utf-8")
            .header("X-Powered-By", POWERED_BY)
            .body(Body::from(body))
            .unwrap());
    }

    let mut rows = String::new();
    if let Some(parent_link) = parent_link(requested_path) {
        rows.push_str(&format!(
            r#"
                <tr>
                    <td class="index"></td>
                    <td class="file-name"><a href="{link}">..</a></td>
                    <td class="file-size"></td>
                    <td class="mime"></td>
                    <td class="date"></td>
                </tr>
            "#,
            link = encode_link(&parent_link)
        ));
    }

    for (idx, entry) in entries.iter().enumerate() {
        rows.push_str(&format!(
            r#"
                <tr>
                    <td class="index">{index}</td>
                    <td class="file-name"><a href="{link}">{display}</a></td>
                    <td class="file-size">{size}</td>
                    <td class="mime">{mime}</td>
                    <td class="date">{modified}</td>
                </tr>
            "#,
            index = idx + 1,
            link = entry.relative_url,
            display = encode_text(&entry.display_name),
            size = entry.size_display,
            mime = encode_text(&entry.mime_type),
            modified = entry.modified_display
        ));
    }

    let host = host_header(headers);
    let directory_label = directory_label(requested_path, &host);
    let current_year = Local::now().year();
    let body = template::render_directory_page(&directory_label, &rows, current_year, &host);

    Ok(Response::builder()
        .status(StatusCode::OK)
        .header(header::CONTENT_TYPE, "text/html; charset=utf-8")
        .body(Body::from(body))
        .unwrap())
}

async fn serve_file(
    headers: &HeaderMap,
    requested_path: &str,
    full_path: PathBuf,
    metadata: std::fs::Metadata,
    view: bool,
) -> Result<Response, AppError> {
    let mut file = fs::File::open(&full_path).await.map_err(map_io_error)?;
    let file_size = metadata.len();
    let mut status = StatusCode::OK;
    let mut content_length = file_size;
    let mut content_range: Option<HeaderValue> = None;

    let body = if let Some(range_value) = headers.get(header::RANGE) {
        let range_str = range_value.to_str().unwrap_or("");
        match parse_range_header(range_str, file_size) {
            Ok(Some((start, end))) => {
                status = StatusCode::PARTIAL_CONTENT;
                content_length = end.saturating_sub(start).saturating_add(1);
                file.seek(io::SeekFrom::Start(start))
                    .await
                    .map_err(map_io_error)?;
                let limited = file.take(content_length);
                content_range = Some(
                    HeaderValue::from_str(&format!("bytes {}-{}/{}", start, end, file_size))
                        .unwrap(),
                );
                Body::from_stream(ReaderStream::with_capacity(limited, STREAM_BUFFER_BYTES))
            }
            Ok(None) => Body::from_stream(ReaderStream::with_capacity(file, STREAM_BUFFER_BYTES)),
            Err(_) => {
                let mut response = Response::builder()
                    .status(StatusCode::RANGE_NOT_SATISFIABLE)
                    .header(header::CONTENT_RANGE, format!("bytes */{}", file_size))
                    .body(Body::empty())
                    .unwrap();
                response
                    .headers_mut()
                    .insert(header::ACCEPT_RANGES, HeaderValue::from_static("bytes"));
                return Ok(response);
            }
        }
    } else {
        Body::from_stream(ReaderStream::with_capacity(file, STREAM_BUFFER_BYTES))
    };

    let mime = MimeGuess::from_path(&full_path)
        .first_or_octet_stream()
        .to_string();

    let disposition_type = if view { "inline" } else { "attachment" };
    let filename = full_path
        .file_name()
        .and_then(|name| name.to_str())
        .unwrap_or("download");

    let mut response = Response::builder()
        .status(status)
        .header(header::CONTENT_TYPE, mime)
        .header(
            header::CONTENT_DISPOSITION,
            format!(r#"{disposition_type}; filename="{filename}""#),
        )
        .body(body)
        .unwrap();

    // Set Content-Length when available.
    response.headers_mut().insert(
        header::CONTENT_LENGTH,
        HeaderValue::from_str(&content_length.to_string()).unwrap(),
    );
    response
        .headers_mut()
        .insert(header::ACCEPT_RANGES, HeaderValue::from_static("bytes"));
    if let Some(value) = content_range {
        response.headers_mut().insert(header::CONTENT_RANGE, value);
    }

    let path_display = if requested_path.is_empty() {
        "/".to_string()
    } else {
        format!("/{}", requested_path.trim_start_matches('/'))
    };
    info!(
        "[downloading] {} - {} - {} - {}",
        client_ip(headers),
        filename,
        path_display,
        client_user_agent(headers)
    );

    Ok(response)
}

fn parse_range_header(value: &str, size: u64) -> Result<Option<(u64, u64)>, ()> {
    let trimmed = value.trim();
    if trimmed.is_empty() {
        return Err(());
    }
    if !trimmed.starts_with("bytes=") {
        return Ok(None);
    }

    let spec = trimmed[6..].trim();
    if spec.is_empty() || spec.contains(',') {
        return Err(());
    }

    let (start_part, end_part) = spec.split_once('-').ok_or(())?;
    let start_part = start_part.trim();
    let end_part = end_part.trim();

    if start_part.is_empty() {
        if end_part.is_empty() {
            return Err(());
        }
        let suffix: u64 = end_part.parse().map_err(|_| ())?;
        if suffix == 0 || size == 0 {
            return Err(());
        }
        let length = suffix.min(size);
        let start = size - length;
        let end = size - 1;
        Ok(Some((start, end)))
    } else {
        let start: u64 = start_part.parse().map_err(|_| ())?;
        let end = if end_part.is_empty() {
            size.checked_sub(1).ok_or(())?
        } else {
            end_part.parse().map_err(|_| ())?
        };
        if start > end || end >= size {
            return Err(());
        }
        Ok(Some((start, end)))
    }
}

fn is_upload_cancelled(err: &MultipartError) -> bool {
    let message = err.to_string();
    message.contains("connection closed")
        || message.contains("Incomplete")
        || message.contains("multipart/form-data")
}

async fn handle_upload(
    State(state): State<AppState>,
    headers: HeaderMap,
    Query(query): Query<UploadQuery>,
    mut multipart: Multipart,
) -> Result<Response, AppError> {
    let provided_token = headers
        .get("X-Upload-Token")
        .and_then(|value| value.to_str().ok());
    if provided_token != Some(state.config.upload_token.as_str()) {
        return Err(AppError::Unauthorized("Unauthorized".to_string()));
    }

    let mut target_dir_path = query.path.unwrap_or_default();
    if let Some(header_path) = headers
        .get("X-Upload-Path")
        .and_then(|value| value.to_str().ok())
        .map(str::trim)
        .filter(|value| !value.is_empty())
    {
        target_dir_path = header_path.to_string();
    }

    let mut saved_file = None;

    loop {
        let mut field = match multipart.next_field().await {
            Ok(Some(field)) => field,
            Ok(None) => break,
            Err(err) => {
                if is_upload_cancelled(&err) {
                    info!("Upload aborted by client: {}", err);
                    let status = StatusCode::from_u16(499).unwrap_or(StatusCode::BAD_REQUEST);
                    return Ok(Response::builder()
                        .status(status)
                        .body(Body::empty())
                        .unwrap());
                }
                error!("Multipart parsing error: {}", err);
                return Err(AppError::BadRequest(
                    "Invalid multipart payload".to_string(),
                ));
            }
        };

        if field.name() == Some("path") {
            let text = field.text().await.map_err(|err| {
                error!("Failed to read path field: {}", err);
                AppError::BadRequest("Invalid directory path".to_string())
            })?;
            let trimmed = text.trim();
            if !trimmed.is_empty() {
                target_dir_path = trimmed.to_string();
            }
            continue;
        }

        if field.name() != Some("file") {
            continue;
        }

        let file_name = field
            .file_name()
            .map(|name| name.to_string())
            .unwrap_or_default();

        if file_name.is_empty() {
            return Err(AppError::BadRequest(
                "No selected file or file type not allowed".to_string(),
            ));
        }

        let allow_missing_extension = headers
            .get("X-Allow-No-Ext")
            .and_then(|value| value.to_str().ok())
            .map(|value| matches!(value.to_ascii_lowercase().as_str(), "1" | "true" | "yes"))
            .unwrap_or(false);

        let clean_name = StdPath::new(&file_name)
            .file_name()
            .and_then(|name| name.to_str())
            .ok_or_else(|| {
                AppError::BadRequest("No selected file or file type not allowed".to_string())
            })?;

        let has_extension = StdPath::new(clean_name).extension().is_some();
        let extension_allowed = is_allowed_file(clean_name, &state.config.allowed_extensions);

        if !extension_allowed {
            if !(allow_missing_extension && !has_extension) {
                return Err(AppError::BadRequest(
                    "No selected file or file type not allowed".to_string(),
                ));
            }
        }

        let safe_name = secure_filename(clean_name).ok_or_else(|| {
            AppError::BadRequest("No selected file or file type not allowed".to_string())
        })?;

        let target_dir = if target_dir_path.trim().is_empty() {
            state.canonical_root.as_ref().clone()
        } else {
            resolve_within_root(&state.canonical_root, &target_dir_path)
                .ok_or_else(|| AppError::BadRequest("Invalid directory path".to_string()))?
        };

        if !target_dir.starts_with(&*state.canonical_root) {
            return Err(AppError::BadRequest("Invalid directory path".to_string()));
        }

        fs::create_dir_all(&target_dir)
            .await
            .map_err(map_io_error)?;

        let destination_path = target_dir.join(&safe_name);

        if !destination_path.starts_with(&*state.canonical_root) {
            return Err(AppError::BadRequest("Invalid directory path".to_string()));
        }

        let mut output = fs::File::create(&destination_path)
            .await
            .map_err(map_io_error)?;

        let mut total_bytes = 0u64;

        while let Some(chunk) = field.chunk().await.map_err(|err| {
            error!("Failed to read upload chunk: {}", err);
            AppError::Internal("Internal server error".to_string())
        })? {
            total_bytes += chunk.len() as u64;
            if total_bytes > state.config.max_file_size {
                return Err(AppError::BadRequest("File too large".to_string()));
            }
            output.write_all(&chunk).await.map_err(map_io_error)?;
        }

        let mime_type = field
            .content_type()
            .map(|m| m.to_string())
            .unwrap_or_else(|| "application/octet-stream".to_string());

        let relative_path = diff_paths(&destination_path, &*state.canonical_root)
            .unwrap_or_else(|| PathBuf::from(&safe_name));

        let relative_str = relative_path
            .to_string_lossy()
            .replace(std::path::MAIN_SEPARATOR, "/");

        let base_url = build_base_url(&headers);

        saved_file = Some(UploadResponse {
            name: safe_name,
            size: total_bytes.to_string(),
            mime_type,
            created_date: chrono::Utc::now().to_rfc3339(),
            path: relative_str.clone(),
            view: format!("{base_url}{relative_str}?view=true"),
            download: format!("{base_url}{relative_str}"),
        });

        break;
    }

    let saved = saved_file.ok_or_else(|| AppError::BadRequest("No file to upload".to_string()))?;
    let UploadResponse {
        name,
        size,
        mime_type,
        created_date,
        path,
        view,
        download,
    } = saved;

    info!(
        "[uploading] {} - {} - {} - {}",
        client_ip(&headers),
        name,
        path,
        client_user_agent(&headers)
    );

    let payload = serde_json::json!({
        "status": "success",
        "name": name,
        "size": size,
        "created_date": created_date,
        "mime_type": mime_type,
        "path": path,
        "view": view,
        "download": download,
        "powered_by": POWERED_BY,
    });

    let mut response = Response::builder()
        .status(StatusCode::OK)
        .header(header::CONTENT_TYPE, "application/json; charset=utf-8")
        .body(Body::from(serde_json::to_string_pretty(&payload).unwrap()))
        .unwrap();
    response.headers_mut().insert(
        "X-Upload-Server",
        header::HeaderValue::from_static(POWERED_BY),
    );
    Ok(response)
}

fn parent_link(requested_path: &str) -> Option<String> {
    if requested_path.trim().is_empty() {
        return None;
    }

    let mut parts: Vec<&str> = requested_path
        .split('/')
        .filter(|segment| !segment.is_empty())
        .collect();

    if parts.is_empty() {
        return Some("/".to_string());
    }

    parts.pop();
    if parts.is_empty() {
        Some("/".to_string())
    } else {
        Some(format!("/{}", parts.join("/")))
    }
}

fn entry_link(base_path: &str, name: &str) -> String {
    let base = base_path.trim_matches('/');
    if base.is_empty() {
        format!("/{name}")
    } else {
        format!("/{base}/{name}")
    }
}

fn directory_label(requested_path: &str, host: &str) -> String {
    if requested_path.trim().is_empty() {
        host.to_string()
    } else {
        let parts: Vec<&str> = requested_path
            .split('/')
            .filter(|segment| !segment.is_empty())
            .collect();

        if let Some(last) = parts.last() {
            let prefix = "../".repeat(parts.len().saturating_sub(1));
            format!("{prefix}{last}/")
        } else {
            format!("{requested_path}/")
        }
    }
}

fn host_header(headers: &HeaderMap) -> String {
    headers
        .get(header::HOST)
        .and_then(|value| value.to_str().ok())
        .unwrap_or("localhost")
        .to_string()
}

fn client_ip(headers: &HeaderMap) -> String {
    const CANDIDATES: [&str; 3] = ["x-forwarded-for", "cf-connecting-ip", "x-real-ip"];

    for name in CANDIDATES {
        if let Some(value) = headers
            .get(name)
            .and_then(|header| header.to_str().ok())
            .and_then(|raw| raw.split(',').next())
            .map(str::trim)
            .filter(|s| !s.is_empty())
        {
            return value.to_string();
        }
    }

    "unknown".to_string()
}

fn client_user_agent(headers: &HeaderMap) -> String {
    headers
        .get(header::USER_AGENT)
        .and_then(|value| value.to_str().ok())
        .map(|ua| ua.to_string())
        .unwrap_or_else(|| "unknown".to_string())
}

fn build_base_url(headers: &HeaderMap) -> String {
    let scheme = headers
        .get("X-Forwarded-Proto")
        .and_then(|value| value.to_str().ok())
        .unwrap_or("http");

    let host = host_header(headers);
    format!("{scheme}://{host}/")
}

fn init_config_file() -> Result<(), Box<dyn std::error::Error>> {
    let home = env::var("HOME").or_else(|_| env::var("USERPROFILE"))?;
    let dir = PathBuf::from(home).join(".config").join("serve");
    std::fs::create_dir_all(&dir)?;

    let path = dir.join("config.toml");
    if path.exists() {
        return Err(format!("config already exists at {}", path.display()).into());
    }

    std::fs::write(&path, DEFAULT_CONFIG_BODY)?;
    println!("Config written to {}", path.display());
    Ok(())
}

fn map_io_error(err: io::Error) -> AppError {
    match err.kind() {
        io::ErrorKind::NotFound => AppError::NotFound(NOT_FOUND_MESSAGE.to_string()),
        io::ErrorKind::PermissionDenied => AppError::NotFound(NOT_FOUND_MESSAGE.to_string()),
        _ => {
            error!("IO error: {}", err);
            AppError::Internal("Internal server error".to_string())
        }
    }
}

#[derive(Debug)]
struct DirectoryEntry {
    name: String,
    display_name: String,
    relative_url: String,
    size_bytes: u64,
    size_display: String,
    modified_display: String,
    is_dir: bool,
    mime_type: String,
}

#[derive(Debug)]
struct UploadResponse {
    name: String,
    size: String,
    mime_type: String,
    created_date: String,
    path: String,
    view: String,
    download: String,
}

#[derive(Debug)]
enum AppError {
    NotFound(String),
    Unauthorized(String),
    BadRequest(String),
    Internal(String),
    Config(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AppError::NotFound(message)
            | AppError::Unauthorized(message)
            | AppError::BadRequest(message)
            | AppError::Internal(message)
            | AppError::Config(message) => write!(f, "{message}"),
        }
    }
}

impl std::error::Error for AppError {}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        match self {
            AppError::NotFound(message) => (StatusCode::NOT_FOUND, message).into_response(),
            AppError::Unauthorized(message) => (StatusCode::UNAUTHORIZED, message).into_response(),
            AppError::BadRequest(message) => (StatusCode::BAD_REQUEST, message).into_response(),
            AppError::Internal(message) => {
                (StatusCode::INTERNAL_SERVER_ERROR, message).into_response()
            }
            AppError::Config(message) => {
                (StatusCode::INTERNAL_SERVER_ERROR, message).into_response()
            }
        }
    }
}
