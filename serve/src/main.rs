mod browse;
mod config;
mod http_utils;
mod template;
mod uploads;
mod utils;

use axum::{
    Router,
    extract::DefaultBodyLimit,
    http::{Extensions, HeaderMap, HeaderValue, StatusCode, Version, header},
    response::{IntoResponse, Response},
    routing::{get, post, put},
};
use clap::{Args, Parser, Subcommand};
use config::Config;
use std::{env, fmt, io, net::SocketAddr, path::PathBuf, sync::Arc};
use tower::ServiceBuilder;
use tower_http::{
    compression::CompressionLayer, set_header::SetResponseHeaderLayer, trace::TraceLayer,
};
use tracing::{error, info};
use tracing_subscriber::EnvFilter;

const NOT_FOUND_MESSAGE: &str = "Files or Directory not found or missing";
const DEFAULT_CONFIG_BODY: &str = r#"# Generated by serve
port = 3435
root = "./serve"
upload_token = "abogoboga"
max_file_size = 4194304000
blacklisted_files = ["utils", "server.py"]
allowed_extensions = [
  "mp3", "wav", "mp4", "zip", "pdf", "png", "jpg"
]
"#;
const POWERED_BY: &str = concat!("serve/", env!("CARGO_PKG_VERSION"));
// Smaller chunk keeps initial response snappy while still streaming efficiently.
const STREAM_BUFFER_BYTES: usize = 256 * 1024;

#[derive(Parser)]
#[command(
    name = "serve",
    version,
    about = "Serve files over HTTP with optional upload support.",
    long_about = None
)]
struct Cli {
    #[command(subcommand)]
    command: Command,
}

#[derive(Args, Clone)]
struct RunArgs {
    /// Path to configuration file (TOML format)
    #[arg(long, value_name = "FILE")]
    config: Option<PathBuf>,
    /// Override listening port (defaults to env/config)
    #[arg(long, value_name = "PORT")]
    port: Option<u16>,
    /// Override upload token
    #[arg(long, value_name = "TOKEN")]
    upload_token: Option<String>,
    /// Override maximum upload size in bytes
    #[arg(long, value_name = "BYTES")]
    max_file_size: Option<u64>,
    /// Override root directory to serve
    #[arg(long, value_name = "PATH")]
    root: Option<PathBuf>,
}

#[derive(Subcommand)]
enum Command {
    /// Run the HTTP file server
    Run(RunArgs),
    /// Generate a default configuration file at $HOME/.config/serve/config.toml
    InitConfig,
    /// Print the effective configuration and exit
    ShowConfig(RunArgs),
}

#[derive(Clone)]
pub(crate) struct AppState {
    pub(crate) config: Arc<Config>,
    pub(crate) canonical_root: Arc<PathBuf>,
}

#[tokio::main(flavor = "multi_thread", worker_threads = 4)]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    tracing_subscriber::fmt()
        .with_env_filter(
            EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| EnvFilter::new("serve=info,tower_http=info")),
        )
        .init();

    match Cli::parse().command {
        Command::Run(args) => run_server(args)
            .await
            .map_err(|err| -> Box<dyn std::error::Error> { Box::new(err) })?,
        Command::InitConfig => init_config_file()?,
        Command::ShowConfig(args) => show_config(args)?,
    }

    Ok(())
}

fn effective_config(args: &RunArgs) -> Result<(Config, PathBuf), AppError> {
    let mut config =
        Config::load(args.config.as_deref()).map_err(|err| AppError::Config(err.to_string()))?;

    if let Some(port) = args.port {
        config.port = port;
    }
    if let Some(token) = args.upload_token.clone() {
        config.upload_token = token;
    }
    if let Some(size) = args.max_file_size {
        config.max_file_size = size;
    }
    if let Some(root) = args.root.clone() {
        config.root_override = Some(root);
    }

    let base_root = config
        .root_override
        .clone()
        .unwrap_or_else(|| env::current_dir().unwrap_or_else(|_| PathBuf::from(".")));
    let canonical_root = base_root
        .canonicalize()
        .map_err(|_| AppError::Internal("Failed to resolve root directory".to_string()))?;

    Ok((config, canonical_root))
}

async fn run_server(args: RunArgs) -> Result<(), AppError> {
    let (config, canonical_root) = effective_config(&args)?;

    let body_limit = config
        .max_file_size
        .saturating_add(32 * 1024 * 1024)
        .try_into()
        .unwrap_or(usize::MAX);

    let state = AppState {
        config: Arc::new(config),
        canonical_root: Arc::new(canonical_root),
    };

    let compression = CompressionLayer::new().compress_when(
        |_status: StatusCode, _version: Version, headers: &HeaderMap, _extensions: &Extensions| {
            headers
                .get(header::CONTENT_TYPE)
                .and_then(|value| value.to_str().ok())
                .map(|content_type| {
                    content_type.starts_with("text/")
                        || content_type.contains("json")
                        || content_type.contains("xml")
                        || content_type.contains("javascript")
                })
                .unwrap_or(false)
        },
    );

    let powered_layer = SetResponseHeaderLayer::if_not_present(
        header::HeaderName::from_static("x-powered-by"),
        HeaderValue::from_static(POWERED_BY),
    );

    let router = Router::new()
        .route("/", get(browse::get_root))
        .route("/*path", get(browse::get_path))
        .route("/upload", post(uploads::handle_upload))
        .route(
            "/upload-stream",
            put(uploads::handle_upload_stream).post(uploads::handle_upload_stream),
        )
        .layer(DefaultBodyLimit::max(body_limit))
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(compression)
                .layer(powered_layer),
        )
        .with_state(state.clone());

    let addr = SocketAddr::from(([0, 0, 0, 0], state.config.port));
    info!(
        "Config loaded: port={} token_set={} max_file_size={} allowed_ext={} hidden={}",
        state.config.port,
        !state.config.upload_token.is_empty(),
        state.config.max_file_size,
        state.config.allowed_extensions.len(),
        state.config.blacklisted_files.len()
    );
    info!(
        "Starting server on {} serving {}",
        addr,
        state.canonical_root.display()
    );
    let listener = tokio::net::TcpListener::bind(addr).await.map_err(|err| {
        error!("Failed to bind to {}: {}", addr, err);
        AppError::Config(format!("Failed to bind to {addr}: {err}"))
    })?;

    axum::serve(listener, router)
        .await
        .map_err(|err| {
        error!("Server error: {}", err);
        AppError::Internal("Server error".to_string())
    })
}

fn show_config(args: RunArgs) -> Result<(), AppError> {
    let (config, canonical_root) = effective_config(&args)?;

    println!("serve {}", env!("CARGO_PKG_VERSION"));
    println!(
        "Config file    : {}",
        args.config
            .as_ref()
            .map(|p| p.display().to_string())
            .unwrap_or_else(|| "<auto-discovery>".to_string())
    );
    println!("Port           : {}", config.port);
    println!("Root (effective): {}", canonical_root.display());
    println!(
        "Root override  : {}",
        config
            .root_override
            .as_ref()
            .map(|p| p.display().to_string())
            .unwrap_or_else(|| "<not set>".to_string())
    );
    println!(
        "Upload token   : {}",
        if config.upload_token.is_empty() {
            "<not set>".to_string()
        } else {
            config.upload_token.clone()
        }
    );
    println!("Max file size  : {} bytes", config.max_file_size);

    let mut hidden: Vec<_> = config.blacklisted_files.iter().cloned().collect();
    hidden.sort();
    println!(
        "Hidden entries : {}",
        if hidden.is_empty() {
            "-".to_string()
        } else {
            hidden.join(", ")
        }
    );

    let mut extensions: Vec<_> = config.allowed_extensions.iter().cloned().collect();
    extensions.sort();
    println!(
        "Allowed ext    : {}",
        if extensions.is_empty() {
            "-".to_string()
        } else {
            extensions.join(", ")
        }
    );

    Ok(())
}

fn init_config_file() -> Result<(), Box<dyn std::error::Error>> {
    let home = env::var("HOME").or_else(|_| env::var("USERPROFILE"))?;
    let dir = PathBuf::from(home).join(".config").join("serve");
    std::fs::create_dir_all(&dir)?;

    let path = dir.join("config.toml");
    if path.exists() {
        return Err(format!("config already exists at {}", path.display()).into());
    }

    std::fs::write(&path, DEFAULT_CONFIG_BODY)?;
    println!("Config written to {}", path.display());
    Ok(())
}

pub(crate) fn map_io_error(err: io::Error) -> AppError {
    match err.kind() {
        io::ErrorKind::NotFound => AppError::NotFound(NOT_FOUND_MESSAGE.to_string()),
        io::ErrorKind::PermissionDenied => AppError::NotFound(NOT_FOUND_MESSAGE.to_string()),
        _ => {
            error!("IO error: {}", err);
            AppError::Internal("Internal server error".to_string())
        }
    }
}

#[derive(Debug)]
pub(crate) enum AppError {
    NotFound(String),
    Unauthorized(String),
    BadRequest(String),
    Internal(String),
    Config(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AppError::NotFound(message)
            | AppError::Unauthorized(message)
            | AppError::BadRequest(message)
            | AppError::Internal(message)
            | AppError::Config(message) => write!(f, "{message}"),
        }
    }
}

impl std::error::Error for AppError {}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        match self {
            AppError::NotFound(message) => (StatusCode::NOT_FOUND, message).into_response(),
            AppError::Unauthorized(message) => (StatusCode::UNAUTHORIZED, message).into_response(),
            AppError::BadRequest(message) => (StatusCode::BAD_REQUEST, message).into_response(),
            AppError::Internal(message) => {
                (StatusCode::INTERNAL_SERVER_ERROR, message).into_response()
            }
            AppError::Config(message) => {
                (StatusCode::INTERNAL_SERVER_ERROR, message).into_response()
            }
        }
    }
}
