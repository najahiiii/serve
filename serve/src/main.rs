mod browse;
mod catalog;
mod config;
mod http_utils;
mod template;
mod uploads;
mod utils;

use axum::{
    Router,
    extract::DefaultBodyLimit,
    http::{Extensions, HeaderMap, HeaderValue, StatusCode, Version, header},
    response::{IntoResponse, Response},
    routing::{delete, get, post, put},
};
use catalog::{Catalog, CatalogCommand, CatalogWorker};
use clap::{Args, Parser, Subcommand};
use config::{Config, RootSource};
use rand::{Rng, distributions::Alphanumeric, rngs::OsRng};
#[cfg(unix)]
use std::os::unix::fs::OpenOptionsExt;
use std::{
    env, fmt, fs,
    io::{self, Write},
    net::SocketAddr,
    path::PathBuf,
    sync::Arc,
};
use tokio::sync::mpsc;
use tower::ServiceBuilder;
use tower_http::{
    compression::CompressionLayer, set_header::SetResponseHeaderLayer, trace::TraceLayer,
};
use tracing::{error, info};
use tracing_subscriber::EnvFilter;

const NOT_FOUND_MESSAGE: &str = "Files or Directory not found or missing";
const DEFAULT_CONFIG_BODY_TEMPLATE: &str = r#"# Generated by serve
port = 3435
root = "./serve"
upload_token = "{token}"
max_file_size = 4194304000
blacklisted_files = ["utils", "server.py"]
allowed_extensions = [
  "mp3", "wav", "mp4", "zip", "pdf", "png", "jpg"
]
catalog_refresh_secs = 300
"#;
const POWERED_BY: &str = concat!("serve/", env!("CARGO_PKG_VERSION"));
// Smaller chunk keeps initial response snappy while still streaming efficiently.
const STREAM_BUFFER_BYTES: usize = 256 * 1024;
const GENERATED_TOKEN_LEN: usize = 32;

fn default_config_body(token: &str) -> String {
    DEFAULT_CONFIG_BODY_TEMPLATE.replace("{token}", token)
}

fn generate_upload_token() -> String {
    OsRng
        .sample_iter(&Alphanumeric)
        .take(GENERATED_TOKEN_LEN)
        .map(char::from)
        .collect()
}

#[derive(Parser)]
#[command(
    name = "serve",
    version,
    about = "Serve files over HTTP with optional upload support.",
    long_about = None
)]
struct Cli {
    #[command(subcommand)]
    command: Command,
}

#[derive(Args, Clone)]
struct RunArgs {
    /// Path to configuration file (TOML format)
    #[arg(long, value_name = "FILE")]
    config: Option<PathBuf>,
    /// Override listening port (defaults to env/config)
    #[arg(long, value_name = "PORT")]
    port: Option<u16>,
    /// Override upload token
    #[arg(long, value_name = "TOKEN")]
    upload_token: Option<String>,
    /// Override maximum upload size in bytes
    #[arg(long, value_name = "BYTES")]
    max_file_size: Option<u64>,
    /// Override root directory to serve
    #[arg(long, value_name = "PATH")]
    root: Option<PathBuf>,
}

#[derive(Args, Clone)]
struct ShowConfigArgs {
    #[command(flatten)]
    run: RunArgs,
    /// Display the configured upload token
    #[arg(long)]
    show_token: bool,
}

#[derive(Subcommand)]
enum Command {
    /// Run the HTTP file server
    Run(RunArgs),
    /// Generate a default configuration file at $HOME/.config/serve/config.toml
    InitConfig,
    /// Print the effective configuration and exit
    ShowConfig(ShowConfigArgs),
}

#[derive(Clone)]
pub(crate) struct AppState {
    pub(crate) config: Arc<Config>,
    pub(crate) canonical_root: Arc<PathBuf>,
    pub(crate) catalog: Arc<Catalog>,
    pub(crate) catalog_events: mpsc::Sender<CatalogCommand>,
}

#[tokio::main(flavor = "multi_thread", worker_threads = 4)]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    tracing_subscriber::fmt()
        .with_env_filter(
            EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| EnvFilter::new("serve=info,tower_http=info")),
        )
        .init();

    match Cli::parse().command {
        Command::Run(args) => run_server(args)
            .await
            .map_err(|err| -> Box<dyn std::error::Error> { Box::new(err) })?,
        Command::InitConfig => init_config_file()?,
        Command::ShowConfig(args) => show_config(args)?,
    }

    Ok(())
}

fn effective_config(args: &RunArgs) -> Result<(Config, PathBuf), AppError> {
    let mut config =
        Config::load(args.config.as_deref()).map_err(|err| AppError::Config(err.to_string()))?;

    if let Some(port) = args.port {
        config.port = port;
    }
    if let Some(token) = args.upload_token.clone() {
        config.upload_token = token;
    }
    if let Some(size) = args.max_file_size {
        config.max_file_size = size;
    }
    if let Some(root) = args.root.clone() {
        config.root_override = Some(root);
        config.root_source = RootSource::Cli;
    }

    let current_dir = || env::current_dir().unwrap_or_else(|_| PathBuf::from("."));
    let config_dir = config.config_dir.clone().unwrap_or_else(|| current_dir());

    let base_root = match config.root_override.clone() {
        Some(root) if root.is_absolute() => root,
        Some(root) => match config.root_source {
            RootSource::ConfigFile | RootSource::EnvVar | RootSource::Default => {
                config_dir.join(root)
            }
            RootSource::Cli => current_dir().join(root),
        },
        None => config_dir,
    };
    let canonical_root = base_root
        .canonicalize()
        .map_err(|_| AppError::Internal("Failed to resolve root directory".to_string()))?;

    Ok((config, canonical_root))
}

async fn run_server(args: RunArgs) -> Result<(), AppError> {
    let (config, canonical_root) = effective_config(&args)?;

    let body_limit = config
        .max_file_size
        .saturating_add(32 * 1024 * 1024)
        .try_into()
        .unwrap_or(usize::MAX);

    let config = Arc::new(config);
    let canonical_root = Arc::new(canonical_root);

    let storage_dir = config.storage_dir();
    fs::create_dir_all(&storage_dir)
        .map_err(|err| AppError::Internal(format!("Failed to prepare config dir: {err}")))?;
    let catalog_path = storage_dir.join("catalog.db");
    let catalog = Arc::new(
        Catalog::new(&catalog_path)
            .await
            .map_err(|err| AppError::Internal(format!("Failed to initialize catalog: {err:?}")))?,
    );

    let (catalog_tx, catalog_rx) = mpsc::channel(8);
    let worker = CatalogWorker::new(
        catalog.clone(),
        canonical_root.clone(),
        Arc::new(config.blacklisted_files.clone()),
        config.catalog_refresh_secs,
        catalog_rx,
    );
    tokio::spawn(async move {
        worker.run().await;
    });
    let _ = catalog_tx.try_send(CatalogCommand::RefreshAll);

    let state = AppState {
        config: config.clone(),
        canonical_root: canonical_root.clone(),
        catalog: catalog.clone(),
        catalog_events: catalog_tx.clone(),
    };

    let compression = CompressionLayer::new().compress_when(
        |_status: StatusCode, _version: Version, headers: &HeaderMap, _extensions: &Extensions| {
            headers
                .get(header::CONTENT_TYPE)
                .and_then(|value| value.to_str().ok())
                .map(|content_type| {
                    content_type.starts_with("text/")
                        || content_type.contains("json")
                        || content_type.contains("xml")
                        || content_type.contains("javascript")
                })
                .unwrap_or(false)
        },
    );

    let powered_layer = SetResponseHeaderLayer::if_not_present(
        header::HeaderName::from_static("x-powered-by"),
        HeaderValue::from_static(POWERED_BY),
    );

    let router = Router::new()
        .route("/", get(browse::get_root))
        .route("/download", get(browse::download_by_id))
        .route("/list", get(browse::list_by_id))
        .route("/info", get(browse::get_info))
        .route("/delete", delete(browse::delete_by_id))
        .route("/upload", post(uploads::handle_upload))
        .route(
            "/upload-stream",
            put(uploads::handle_upload_stream).post(uploads::handle_upload_stream),
        )
        .layer(DefaultBodyLimit::max(body_limit))
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(compression)
                .layer(powered_layer),
        )
        .with_state(state.clone());

    let addr = SocketAddr::from(([0, 0, 0, 0], state.config.port));
    info!(
        "Config loaded: port={} token_set={} max_file_size={} allowed_ext={} hidden={}",
        state.config.port,
        !state.config.upload_token.is_empty(),
        state.config.max_file_size,
        state.config.allowed_extensions.len(),
        state.config.blacklisted_files.len()
    );
    info!(
        "Starting server on {} serving {}",
        addr,
        state.canonical_root.display()
    );
    let listener = tokio::net::TcpListener::bind(addr).await.map_err(|err| {
        error!("Failed to bind to {}: {}", addr, err);
        AppError::Config(format!(
            "Failed to bind to {addr}. Ensure the port is free and you have permission."
        ))
    })?;

    axum::serve(listener, router).await.map_err(|err| {
        error!("Server error: {}", err);
        AppError::Internal("Server error".to_string())
    })
}

fn show_config(args: ShowConfigArgs) -> Result<(), AppError> {
    let (config, canonical_root) = effective_config(&args.run)?;

    println!("serve {}", env!("CARGO_PKG_VERSION"));
    println!(
        "Config file    : {}",
        args.run
            .config
            .as_ref()
            .map(|p| p.display().to_string())
            .unwrap_or_else(|| "<auto-discovery>".to_string())
    );
    println!("Port           : {}", config.port);
    println!("Root (effective): {}", canonical_root.display());
    println!(
        "Root override  : {}",
        config
            .root_override
            .as_ref()
            .map(|p| p.display().to_string())
            .unwrap_or_else(|| "<not set>".to_string())
    );
    println!(
        "Upload token   : {}",
        if config.upload_token.is_empty() {
            "<not set>".to_string()
        } else if args.show_token {
            config.upload_token.clone()
        } else {
            "<hidden>".to_string()
        }
    );
    println!("Max file size  : {} bytes", config.max_file_size);
    println!("Catalog refresh: {} seconds", config.catalog_refresh_secs);

    let mut hidden: Vec<_> = config.blacklisted_files.iter().cloned().collect();
    hidden.sort();
    println!(
        "Hidden entries : {}",
        if hidden.is_empty() {
            "-".to_string()
        } else {
            hidden.join(", ")
        }
    );

    let mut extensions: Vec<_> = config.allowed_extensions.iter().cloned().collect();
    extensions.sort();
    println!(
        "Allowed ext    : {}",
        if extensions.is_empty() {
            "-".to_string()
        } else {
            extensions.join(", ")
        }
    );
    if !config.upload_token.is_empty() && !args.show_token {
        println!();
        println!("Tip: pass --show-token to display the configured token");
    }

    Ok(())
}

fn init_config_file() -> Result<(), Box<dyn std::error::Error>> {
    let dir = config::default_config_dir();
    fs::create_dir_all(&dir)?;

    let path = dir.join("config.toml");
    if path.exists() {
        return Err(format!("config already exists at {}", path.display()).into());
    }

    let token = generate_upload_token();
    let body = default_config_body(&token);

    let mut options = fs::OpenOptions::new();
    options.write(true).create_new(true);
    #[cfg(unix)]
    {
        options.mode(0o600);
    }
    let mut file = options.open(&path)?;
    file.write_all(body.as_bytes())?;
    file.flush()?;
    file.sync_all()?;

    println!("Config written to {}", path.display());
    if token.is_empty() {
        println!("No upload token set in config.");
    } else {
        println!("Upload token stored; use `serve show-config --show-token` to view it.");
    }
    Ok(())
}

pub(crate) fn map_io_error(err: io::Error) -> AppError {
    match err.kind() {
        io::ErrorKind::NotFound => AppError::NotFound(NOT_FOUND_MESSAGE.to_string()),
        io::ErrorKind::PermissionDenied => AppError::NotFound(NOT_FOUND_MESSAGE.to_string()),
        _ => {
            error!("IO error: {}", err);
            AppError::Internal("Internal server error".to_string())
        }
    }
}

#[derive(Debug)]
pub(crate) enum AppError {
    NotFound(String),
    Unauthorized(String),
    BadRequest(String),
    Internal(String),
    Config(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AppError::NotFound(message)
            | AppError::Unauthorized(message)
            | AppError::BadRequest(message)
            | AppError::Internal(message)
            | AppError::Config(message) => write!(f, "{message}"),
        }
    }
}

impl std::error::Error for AppError {}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        match self {
            AppError::NotFound(message) => (StatusCode::NOT_FOUND, message).into_response(),
            AppError::Unauthorized(message) => (StatusCode::UNAUTHORIZED, message).into_response(),
            AppError::BadRequest(message) => (StatusCode::BAD_REQUEST, message).into_response(),
            AppError::Internal(message) => {
                (StatusCode::INTERNAL_SERVER_ERROR, message).into_response()
            }
            AppError::Config(message) => {
                (StatusCode::INTERNAL_SERVER_ERROR, message).into_response()
            }
        }
    }
}
