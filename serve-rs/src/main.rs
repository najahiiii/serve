mod config;
mod template;
mod utils;

use axum::{
    Router,
    body::Body,
    extract::{DefaultBodyLimit, Multipart, Path, Query, State},
    http::{Extensions, HeaderMap, HeaderValue, StatusCode, Uri, Version, header},
    response::{IntoResponse, Response},
    routing::{get, post},
};
use chrono::{Datelike, Local};
use clap::{Parser, Subcommand};
use config::Config;
use mime_guess::MimeGuess;
use pathdiff::diff_paths;
use serde::Deserialize;
use std::{
    env, fmt, io,
    net::SocketAddr,
    path::{Path as StdPath, PathBuf},
    sync::Arc,
};
use tokio::fs;
use tokio::io::AsyncWriteExt;
use tokio_util::io::ReaderStream;
use tower::ServiceBuilder;
use tower_http::{
    compression::CompressionLayer, set_header::SetResponseHeaderLayer, trace::TraceLayer,
};
use tracing::{error, info};
use tracing_subscriber::EnvFilter;
use utils::{
    encode_link, format_modified_time, format_size, is_allowed_file, is_blacklisted,
    resolve_within_root, secure_filename,
};

const NOT_FOUND_MESSAGE: &str = "Files or Directory not found or missing";
const DEFAULT_CONFIG_BODY: &str = r#"# Generated by serve-rs
port = 3435
root = "./serve"
upload_token = "abogoboga"
max_file_size = 4194304000
blacklisted_files = ["utils", "server.py"]
allowed_extensions = [
  "mp3", "wav", "mp4", "zip", "pdf", "png", "jpg"
]
"#;
const POWERED_BY: &str = concat!("serve-rs/", env!("CARGO_PKG_VERSION"));

#[derive(Parser)]
#[command(
    name = "serve-rs",
    version,
    about = "Serve files over HTTP with optional upload support.",
    long_about = None
)]
struct Cli {
    #[command(subcommand)]
    command: Command,
}

#[derive(Subcommand)]
enum Command {
    /// Run the HTTP file server
    Run {
        /// Path to configuration file (TOML format)
        #[arg(long, value_name = "FILE")]
        config: Option<PathBuf>,
        /// Override listening port (defaults to env/config)
        #[arg(long, value_name = "PORT")]
        port: Option<u16>,
        /// Override upload token
        #[arg(long, value_name = "TOKEN")]
        upload_token: Option<String>,
        /// Override maximum upload size in bytes
        #[arg(long, value_name = "BYTES")]
        max_file_size: Option<u64>,
        /// Override root directory to serve
        #[arg(long, value_name = "PATH")]
        root: Option<PathBuf>,
    },
    /// Generate a default configuration file at $HOME/.config/serve/config.toml
    InitConfig,
}

#[derive(Clone)]
struct AppState {
    config: Arc<Config>,
    canonical_root: Arc<PathBuf>,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    tracing_subscriber::fmt()
        .with_env_filter(
            EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| EnvFilter::new("serve_rs=info,tower_http=info")),
        )
        .init();

    match Cli::parse().command {
        Command::Run {
            config,
            port,
            upload_token,
            max_file_size,
            root,
        } => run_server(config, port, upload_token, max_file_size, root)
            .await
            .map_err(|err| -> Box<dyn std::error::Error> { Box::new(err) })?,
        Command::InitConfig => init_config_file()?,
    }

    Ok(())
}

async fn run_server(
    config_path: Option<PathBuf>,
    port_override: Option<u16>,
    upload_token_override: Option<String>,
    max_file_size_override: Option<u64>,
    root_override: Option<PathBuf>,
) -> Result<(), AppError> {
    let mut config =
        Config::load(config_path.as_deref()).map_err(|err| AppError::Config(err.to_string()))?;

    if let Some(port) = port_override {
        config.port = port;
    }
    if let Some(token) = upload_token_override {
        config.upload_token = token;
    }
    if let Some(size) = max_file_size_override {
        config.max_file_size = size;
    }
    if let Some(root) = root_override {
        config.root_override = Some(root);
    }

    let base_root = config
        .root_override
        .clone()
        .unwrap_or_else(|| std::env::current_dir().unwrap_or_else(|_| PathBuf::from(".")));
    let canonical_root = base_root
        .canonicalize()
        .map_err(|_| AppError::Internal("Failed to resolve root directory".to_string()))?;

    let body_limit = config
        .max_file_size
        .saturating_add(32 * 1024 * 1024)
        .try_into()
        .unwrap_or(usize::MAX);

    let state = AppState {
        config: Arc::new(config),
        canonical_root: Arc::new(canonical_root),
    };

    let compression = CompressionLayer::new().compress_when(
        |_status: StatusCode, _version: Version, headers: &HeaderMap, _extensions: &Extensions| {
            headers
                .get(header::CONTENT_TYPE)
                .and_then(|value| value.to_str().ok())
                .map(|content_type| {
                    content_type.starts_with("text/")
                        || content_type.contains("json")
                        || content_type.contains("xml")
                        || content_type.contains("javascript")
                })
                .unwrap_or(false)
        },
    );

    let powered_layer = SetResponseHeaderLayer::if_not_present(
        header::HeaderName::from_static("x-powered-by"),
        HeaderValue::from_static(POWERED_BY),
    );

    let router = Router::new()
        .route("/", get(get_root))
        .route("/*path", get(get_path))
        .route("/upload", post(handle_upload))
        .layer(DefaultBodyLimit::max(body_limit))
        .layer(
            ServiceBuilder::new()
                .layer(TraceLayer::new_for_http())
                .layer(compression)
                .layer(powered_layer),
        )
        .with_state(state.clone());

    let addr = SocketAddr::from(([0, 0, 0, 0], state.config.port));
    info!(
        "Config loaded: port={} token_set={} max_file_size={} allowed_ext={} hidden={}",
        state.config.port,
        !state.config.upload_token.is_empty(),
        state.config.max_file_size,
        state.config.allowed_extensions.len(),
        state.config.blacklisted_files.len()
    );
    info!(
        "Starting server on {} serving {}",
        addr,
        state.canonical_root.display()
    );
    axum::serve(
        tokio::net::TcpListener::bind(addr)
            .await
            .map_err(map_io_error)?,
        router,
    )
    .await
    .map_err(|err| {
        error!("Server error: {}", err);
        AppError::Internal("Server error".to_string())
    })
}

async fn get_root(
    State(state): State<AppState>,
    headers: HeaderMap,
    Query(query): Query<ViewQuery>,
) -> Result<Response, AppError> {
    serve_path(state, headers, "", query).await
}

async fn get_path(
    State(state): State<AppState>,
    Path(path): Path<String>,
    headers: HeaderMap,
    Query(query): Query<ViewQuery>,
) -> Result<Response, AppError> {
    serve_path(state, headers, &path, query).await
}

#[derive(Debug, Deserialize)]
struct ViewQuery {
    #[serde(default)]
    view: Option<bool>,
}

#[derive(Debug, Deserialize)]
struct UploadQuery {
    #[serde(default)]
    path: Option<String>,
}

async fn serve_path(
    state: AppState,
    headers: HeaderMap,
    requested_path: &str,
    query: ViewQuery,
) -> Result<Response, AppError> {
    let full_path = resolve_within_root(&state.canonical_root, requested_path)
        .ok_or_else(|| AppError::NotFound(NOT_FOUND_MESSAGE.to_string()))?;

    if is_blacklisted(
        &full_path,
        &state.canonical_root,
        &state.config.blacklisted_files,
    ) {
        return Err(AppError::NotFound(NOT_FOUND_MESSAGE.to_string()));
    }

    let metadata = match fs::metadata(&full_path).await {
        Ok(meta) => meta,
        Err(err) => return Err(map_io_error(err)),
    };

    if metadata.is_dir() {
        render_directory(&state, &headers, requested_path, full_path).await
    } else if metadata.is_file() {
        serve_file(
            &headers,
            requested_path,
            full_path,
            metadata,
            query.view.unwrap_or(false),
        )
        .await
    } else {
        Err(AppError::NotFound(NOT_FOUND_MESSAGE.to_string()))
    }
}

async fn render_directory(
    state: &AppState,
    headers: &HeaderMap,
    requested_path: &str,
    directory_path: PathBuf,
) -> Result<Response, AppError> {
    let mut entries = Vec::new();
    let mut read_dir = fs::read_dir(&directory_path).await.map_err(map_io_error)?;

    while let Some(entry) = read_dir.next_entry().await.map_err(map_io_error)? {
        let file_name_os = entry.file_name();
        let file_name = match file_name_os.to_str() {
            Some(name) => name.to_string(),
            None => continue,
        };

        let child_path = entry.path();
        if is_blacklisted(
            &child_path,
            &state.canonical_root,
            &state.config.blacklisted_files,
        ) {
            continue;
        }

        let child_metadata = match entry.metadata().await {
            Ok(metadata) => metadata,
            Err(err) => {
                error!("Skipping {}: {}", child_path.display(), err);
                continue;
            }
        };

        let modified = match child_metadata.modified() {
            Ok(time) => time,
            Err(err) => {
                error!("Failed to read mtime for {}: {}", child_path.display(), err);
                continue;
            }
        };

        entries.push(DirectoryEntry {
            name: file_name,
            is_dir: child_metadata.is_dir(),
            size: child_metadata.len(),
            modified,
        });
    }

    entries.sort_by(|a, b| a.name.to_lowercase().cmp(&b.name.to_lowercase()));

    let mut rows = String::new();
    if let Some(parent_link) = parent_link(requested_path) {
        rows.push_str(&format!(
            r#"
                <tr>
                    <td colspan="3"><a href="{}">..</a></td>
                </tr>
            "#,
            encode_link(&parent_link)
        ));
    }

    for entry in entries {
        let display_name = if entry.is_dir {
            format!("{}/", entry.name)
        } else {
            entry.name.clone()
        };

        let link = entry_link(requested_path, &entry.name);
        let file_size = if entry.is_dir {
            "-".to_string()
        } else {
            format_size(entry.size)
        };

        let modified_local: chrono::DateTime<Local> = entry.modified.into();
        let modified = format_modified_time(modified_local);

        rows.push_str(&format!(
            r#"
                <tr>
                    <td class="file-name"><a href="{link}">{display}</a></td>
                    <td class="file-size">{size}</td>
                    <td class="date">{modified}</td>
                </tr>
            "#,
            link = encode_link(&link),
            display = display_name,
            size = file_size,
            modified = modified
        ));
    }

    let host = host_header(headers);
    let directory_label = directory_label(requested_path, &host);
    let current_year = Local::now().year();
    let body = template::render_directory_page(&directory_label, &rows, current_year, &host);

    Ok(Response::builder()
        .status(StatusCode::OK)
        .header(header::CONTENT_TYPE, "text/html; charset=utf-8")
        .body(Body::from(body))
        .unwrap())
}

async fn serve_file(
    headers: &HeaderMap,
    requested_path: &str,
    full_path: PathBuf,
    metadata: std::fs::Metadata,
    view: bool,
) -> Result<Response, AppError> {
    let file = fs::File::open(&full_path).await.map_err(map_io_error)?;
    let stream = ReaderStream::with_capacity(file, 1 << 20);
    let body = Body::from_stream(stream);

    let mime = MimeGuess::from_path(&full_path)
        .first_or_octet_stream()
        .to_string();

    let disposition_type = if view { "inline" } else { "attachment" };
    let filename = full_path
        .file_name()
        .and_then(|name| name.to_str())
        .unwrap_or("download");

    let mut response = Response::builder()
        .status(StatusCode::OK)
        .header(header::CONTENT_TYPE, mime)
        .header(
            header::CONTENT_DISPOSITION,
            format!(r#"{disposition_type}; filename="{filename}""#),
        )
        .body(body)
        .unwrap();

    // Set Content-Length when available.
    response.headers_mut().insert(
        header::CONTENT_LENGTH,
        HeaderValue::from_str(&metadata.len().to_string()).unwrap(),
    );
    response
        .headers_mut()
        .insert(header::ACCEPT_RANGES, HeaderValue::from_static("bytes"));

    let path_display = if requested_path.is_empty() {
        "/".to_string()
    } else {
        format!("/{}", requested_path.trim_start_matches('/'))
    };
    info!(
        "[downloading] {} - {} - {} - {}",
        client_ip(headers),
        filename,
        path_display,
        client_user_agent(headers)
    );

    Ok(response)
}

async fn handle_upload(
    State(state): State<AppState>,
    headers: HeaderMap,
    uri: Uri,
    Query(query): Query<UploadQuery>,
    mut multipart: Multipart,
) -> Result<Response, AppError> {
    let provided_token = headers
        .get("X-Upload-Token")
        .and_then(|value| value.to_str().ok());
    if provided_token != Some(state.config.upload_token.as_str()) {
        return Err(AppError::Unauthorized("Unauthorized".to_string()));
    }

    let mut target_dir_path = query.path.unwrap_or_default();
    if let Some(header_path) = headers
        .get("X-Upload-Path")
        .and_then(|value| value.to_str().ok())
        .map(str::trim)
        .filter(|value| !value.is_empty())
    {
        target_dir_path = header_path.to_string();
    }

    let mut saved_file = None;

    while let Some(field) = multipart.next_field().await.map_err(|err| {
        error!("Multipart parsing error: {}", err);
        AppError::BadRequest("Invalid multipart payload".to_string())
    })? {
        if field.name() == Some("path") {
            let text = field.text().await.map_err(|err| {
                error!("Failed to read path field: {}", err);
                AppError::BadRequest("Invalid directory path".to_string())
            })?;
            let trimmed = text.trim();
            if !trimmed.is_empty() {
                target_dir_path = trimmed.to_string();
            }
            continue;
        }

        if field.name() != Some("file") {
            continue;
        }

        let file_name = field
            .file_name()
            .map(|name| name.to_string())
            .unwrap_or_default();

        if file_name.is_empty() {
            return Err(AppError::BadRequest(
                "No selected file or file type not allowed".to_string(),
            ));
        }

        let allow_missing_extension = headers
            .get("X-Allow-No-Ext")
            .and_then(|value| value.to_str().ok())
            .map(|value| matches!(value.to_ascii_lowercase().as_str(), "1" | "true" | "yes"))
            .unwrap_or(false);

        let clean_name = StdPath::new(&file_name)
            .file_name()
            .and_then(|name| name.to_str())
            .ok_or_else(|| {
                AppError::BadRequest("No selected file or file type not allowed".to_string())
            })?;

        let has_extension = StdPath::new(clean_name).extension().is_some();
        let extension_allowed = is_allowed_file(clean_name, &state.config.allowed_extensions);

        if !extension_allowed {
            if !(allow_missing_extension && !has_extension) {
                return Err(AppError::BadRequest(
                    "No selected file or file type not allowed".to_string(),
                ));
            }
        }

        let safe_name = secure_filename(clean_name).ok_or_else(|| {
            AppError::BadRequest("No selected file or file type not allowed".to_string())
        })?;

        let mut file = field;

        let target_dir = if target_dir_path.trim().is_empty() {
            state.canonical_root.as_ref().clone()
        } else {
            resolve_within_root(&state.canonical_root, &target_dir_path)
                .ok_or_else(|| AppError::BadRequest("Invalid directory path".to_string()))?
        };

        if !target_dir.starts_with(&*state.canonical_root) {
            return Err(AppError::BadRequest("Invalid directory path".to_string()));
        }

        fs::create_dir_all(&target_dir)
            .await
            .map_err(map_io_error)?;

        let destination_path = target_dir.join(&safe_name);

        if !destination_path.starts_with(&*state.canonical_root) {
            return Err(AppError::BadRequest("Invalid directory path".to_string()));
        }

        let mut output = fs::File::create(&destination_path)
            .await
            .map_err(map_io_error)?;

        let mut total_bytes = 0u64;

        while let Some(chunk) = file.chunk().await.map_err(|err| {
            error!("Failed to read upload chunk: {}", err);
            AppError::Internal("Internal server error".to_string())
        })? {
            total_bytes += chunk.len() as u64;
            if total_bytes > state.config.max_file_size {
                return Err(AppError::BadRequest("File too large".to_string()));
            }
            output.write_all(&chunk).await.map_err(map_io_error)?;
        }

        let mime_type = file
            .content_type()
            .map(|m| m.to_string())
            .unwrap_or_else(|| "application/octet-stream".to_string());

        let relative_path = diff_paths(&destination_path, &*state.canonical_root)
            .unwrap_or_else(|| PathBuf::from(&safe_name));

        let relative_str = relative_path
            .to_string_lossy()
            .replace(std::path::MAIN_SEPARATOR, "/");

        let base_url = build_base_url(&headers, &uri);

        saved_file = Some(UploadResponse {
            name: safe_name,
            size: total_bytes.to_string(),
            mime_type,
            created_date: chrono::Utc::now().to_rfc3339(),
            path: relative_str.clone(),
            view: format!("{base_url}{relative_str}?view=true"),
            download: format!("{base_url}{relative_str}"),
        });

        break;
    }

    let saved = saved_file.ok_or_else(|| AppError::BadRequest("No file to upload".to_string()))?;
    let UploadResponse {
        name,
        size,
        mime_type,
        created_date,
        path,
        view,
        download,
    } = saved;

    info!(
        "[uploading] {} - {} - {} - {}",
        client_ip(&headers),
        name,
        path,
        client_user_agent(&headers)
    );

    let payload = serde_json::json!({
        "status": "success",
        "name": name,
        "size": size,
        "created_date": created_date,
        "mime_type": mime_type,
        "path": path,
        "view": view,
        "download": download,
        "powered_by": POWERED_BY,
    });

    let mut response = Response::builder()
        .status(StatusCode::OK)
        .header(header::CONTENT_TYPE, "application/json; charset=utf-8")
        .body(Body::from(serde_json::to_string_pretty(&payload).unwrap()))
        .unwrap();
    response.headers_mut().insert(
        "X-Upload-Server",
        header::HeaderValue::from_static(POWERED_BY),
    );
    Ok(response)
}

fn parent_link(requested_path: &str) -> Option<String> {
    if requested_path.trim().is_empty() {
        return None;
    }

    let mut parts: Vec<&str> = requested_path
        .split('/')
        .filter(|segment| !segment.is_empty())
        .collect();

    if parts.is_empty() {
        return Some("/".to_string());
    }

    parts.pop();
    if parts.is_empty() {
        Some("/".to_string())
    } else {
        Some(format!("/{}", parts.join("/")))
    }
}

fn entry_link(base_path: &str, name: &str) -> String {
    let base = base_path.trim_matches('/');
    if base.is_empty() {
        format!("/{name}")
    } else {
        format!("/{base}/{name}")
    }
}

fn directory_label(requested_path: &str, host: &str) -> String {
    if requested_path.trim().is_empty() {
        host.to_string()
    } else {
        let parts: Vec<&str> = requested_path
            .split('/')
            .filter(|segment| !segment.is_empty())
            .collect();

        if let Some(last) = parts.last() {
            let prefix = "../".repeat(parts.len().saturating_sub(1));
            format!("{prefix}{last}/")
        } else {
            format!("{requested_path}/")
        }
    }
}

fn host_header(headers: &HeaderMap) -> String {
    headers
        .get(header::HOST)
        .and_then(|value| value.to_str().ok())
        .unwrap_or("localhost")
        .to_string()
}

fn client_ip(headers: &HeaderMap) -> String {
    const CANDIDATES: [&str; 3] = ["x-forwarded-for", "cf-connecting-ip", "x-real-ip"];

    for name in CANDIDATES {
        if let Some(value) = headers
            .get(name)
            .and_then(|header| header.to_str().ok())
            .and_then(|raw| raw.split(',').next())
            .map(str::trim)
            .filter(|s| !s.is_empty())
        {
            return value.to_string();
        }
    }

    "unknown".to_string()
}

fn client_user_agent(headers: &HeaderMap) -> String {
    headers
        .get(header::USER_AGENT)
        .and_then(|value| value.to_str().ok())
        .map(|ua| ua.to_string())
        .unwrap_or_else(|| "unknown".to_string())
}

fn build_base_url(headers: &HeaderMap, _uri: &Uri) -> String {
    let scheme = headers
        .get("X-Forwarded-Proto")
        .and_then(|value| value.to_str().ok())
        .unwrap_or("http");

    let host = host_header(headers);
    format!("{scheme}://{host}/")
}

fn init_config_file() -> Result<(), Box<dyn std::error::Error>> {
    let home = env::var("HOME").or_else(|_| env::var("USERPROFILE"))?;
    let dir = PathBuf::from(home).join(".config").join("serve");
    std::fs::create_dir_all(&dir)?;

    let path = dir.join("config.toml");
    if path.exists() {
        return Err(format!("config already exists at {}", path.display()).into());
    }

    std::fs::write(&path, DEFAULT_CONFIG_BODY)?;
    println!("Config written to {}", path.display());
    Ok(())
}

fn map_io_error(err: io::Error) -> AppError {
    match err.kind() {
        io::ErrorKind::NotFound => AppError::NotFound(NOT_FOUND_MESSAGE.to_string()),
        io::ErrorKind::PermissionDenied => AppError::NotFound(NOT_FOUND_MESSAGE.to_string()),
        _ => {
            error!("IO error: {}", err);
            AppError::Internal("Internal server error".to_string())
        }
    }
}

#[derive(Debug)]
struct DirectoryEntry {
    name: String,
    is_dir: bool,
    size: u64,
    modified: std::time::SystemTime,
}

#[derive(Debug)]
struct UploadResponse {
    name: String,
    size: String,
    mime_type: String,
    created_date: String,
    path: String,
    view: String,
    download: String,
}

#[derive(Debug)]
enum AppError {
    NotFound(String),
    Unauthorized(String),
    BadRequest(String),
    Internal(String),
    Config(String),
}

impl fmt::Display for AppError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            AppError::NotFound(message)
            | AppError::Unauthorized(message)
            | AppError::BadRequest(message)
            | AppError::Internal(message)
            | AppError::Config(message) => write!(f, "{message}"),
        }
    }
}

impl std::error::Error for AppError {}

impl IntoResponse for AppError {
    fn into_response(self) -> Response {
        match self {
            AppError::NotFound(message) => (StatusCode::NOT_FOUND, message).into_response(),
            AppError::Unauthorized(message) => (StatusCode::UNAUTHORIZED, message).into_response(),
            AppError::BadRequest(message) => (StatusCode::BAD_REQUEST, message).into_response(),
            AppError::Internal(message) => {
                (StatusCode::INTERNAL_SERVER_ERROR, message).into_response()
            }
            AppError::Config(message) => {
                (StatusCode::INTERNAL_SERVER_ERROR, message).into_response()
            }
        }
    }
}
